package org.aksw.jena_sparql_api.example.proxy;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Collection;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.Path;
import javax.ws.rs.core.Context;

import org.aksw.jena_sparql_api.SparqlTest;
import org.aksw.jena_sparql_api.cache.core.QueryExecutionFactoryCacheEx;
import org.aksw.jena_sparql_api.cache.extra.CacheBackend;
import org.aksw.jena_sparql_api.cache.extra.CacheFrontend;
import org.aksw.jena_sparql_api.cache.extra.CacheFrontendImpl;
import org.aksw.jena_sparql_api.cache.h2.CacheCoreH2;
import org.aksw.jena_sparql_api.cache.staging.CacheBackendDao;
import org.aksw.jena_sparql_api.cache.staging.CacheBackendDaoPostgres;
import org.aksw.jena_sparql_api.cache.staging.CacheBackendDataSource;
import org.aksw.jena_sparql_api.core.QueryExecutionFactory;
import org.aksw.jena_sparql_api.http.QueryExecutionFactoryHttp;
import org.aksw.jena_sparql_api.utils.UriUtils;
import org.aksw.jena_sparql_api.web.SparqlEndpointBase;
import org.h2.jdbcx.JdbcDataSource;
import org.h2.tools.RunScript;

import com.google.common.collect.Multimap;
import com.hp.hpl.jena.query.Query;
import com.hp.hpl.jena.query.QueryExecution;



@Path("/sparql")
public class SparqlEndpointProxy
	extends SparqlEndpointBase
{
	private String defaultServiceUri;
	private boolean allowOverrideServiceUri = false;
	
	public SparqlEndpointProxy(@Context ServletContext context) {
		
		this.defaultServiceUri = (String)context.getAttribute("defaultServiceUri");
		
		Boolean tmp = (Boolean)context.getAttribute("allowOverrideServiceUri");
		this.allowOverrideServiceUri = tmp == null ? true : tmp; 
		
		if(!allowOverrideServiceUri && (defaultServiceUri == null || defaultServiceUri.isEmpty()) ) {
			throw new RuntimeException("Overriding of service URI disabled, but no default URI set.");
		}
	}
	
	@Override
	public QueryExecution createQueryExecution(final Query query, @Context HttpServletRequest req) {
		
		Multimap<String, String> qs = UriUtils.parseQueryString(req.getQueryString());
		
		Collection<String> serviceUris = qs.get("service-uri");
		String serviceUri;
		if(serviceUris == null || serviceUris.isEmpty()) {
			serviceUri = defaultServiceUri;
		} else {
			serviceUri = serviceUris.iterator().next();
			
			// If overriding is disabled, a given uri must match the default one
			if(!allowOverrideServiceUri && !defaultServiceUri.equals(serviceUri)) {
				throw new RuntimeException("Access to any service other than " + defaultServiceUri + " is blocked.");
			}
		}
		
		if(serviceUri == null) {
			throw new RuntimeException("No SPARQL service URI sent with the request and no default one is configured");
		}

		
		QueryExecutionFactory qef = new QueryExecutionFactoryHttp(serviceUri);
		QueryExecution result = qef.createQueryExecution(query);
		
		return result;
	}

	@Override
	public QueryExecution createQueryExecution(Query query) {

		//create a query execution over dbpedia
		String serviceUri = "http://dbpedia.org/sparql";
		QueryExecutionFactory qef = new QueryExecutionFactoryHttp(serviceUri);

		//setup caching
		try {
			//cache for a day
			//name the db 'sparql' and use compression
			long ttl = 24l * 60l * 60l * 1000l;
			
			Class.forName("org.h2.Driver");
			
			JdbcDataSource dataSource = new JdbcDataSource();
	        dataSource.setURL("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1");
	        dataSource.setUser("sa");
	        dataSource.setPassword("sa");
	        String sql = ""
	        		//+ "-- Empty - schema currently gets generated by hibernate"
	        		+ "CREATE TABLE IF NOT EXISTS \"query_cache\"("
					+ "		\"id\" text PRIMARY KEY,"// -- ID is usually an MD5 hash of the query string"
					+ "    	\"query_string\" text,"// -- The query string is kept for reference"
					+ "    	\"data\" text,"// -- The result set"
					+ "    	\"hit_count\" int NOT NULL,"// -- Counter for how ofter the cache entry was hit"
					+ "    	\"time_of_insertion\" TIMESTAMP,"
					+ "    	\"time_of_expiration\" TIMESTAMP"
					+ ");"
					+ "CREATE INDEX IF NOT EXISTS \"idx_query_cache_time_of_expiration\" ON \"query_cache\"(\"time_of_expiration\");"
					+ "CREATE INDEX IF NOT EXISTS \"idx_query_cache_hit_count\" ON \"query_cache\"(\"hit_count\");";
	        
	        Reader reader = new StringReader(sql);
	        
	        Connection conn = dataSource.getConnection();
	        try {
	            RunScript.execute(conn, reader);
	        } finally {
	            conn.close();
	        }

			
			CacheBackendDao dao = new CacheBackendDaoPostgres();
	        CacheBackend cacheBackend = new CacheBackendDataSource(dataSource, dao);
	        CacheFrontend cacheFrontend = new CacheFrontendImpl(cacheBackend);
			
			//CacheBackend cacheBackend = CacheCoreH2.create("sparql", ttl, true);
			//CacheFrontend cacheFrontend = new CacheFrontendImpl(cacheBackend);

			qef = new QueryExecutionFactoryCacheEx(qef, cacheFrontend);
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} catch (SQLException e) {
			e.printStackTrace();
		}

		QueryExecution result = qef.createQueryExecution(query);

		return result;
	}
}

